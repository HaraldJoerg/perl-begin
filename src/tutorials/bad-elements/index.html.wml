#include '../template.wml'
#include "xhtml/1.x/std/toc.wml"

<latemp_subject "Perl Elements to Avoid" />

<latemp_more_keywords "elements, antipatterns, anti, patterns, help, ancient, ancient perl, modern, modern perl, avoid, bad perl, old tutorials, what to avoid" />

<h2 id="intro">Introduction</h2>

<p>
Often when people ask for help with Perl code, they show Perl code that
suffers from many bad or outdated elements. This is expected as there
are many bad Perl tutorials out there, and lots of bad code that people
have learned from, but it is still not good. In order to not get "yelled at"
for using these, here is the document of the bad elements that people
tend to use and some better practices that should be used instead.
</p>

<p>
A book I read said, that as opposed to most previous idea systems, they
were trying to <b>liquidate negatives</b> instead of instilling positives
in people. So in the spirit of liquidating negatives, this tutorial-in-reverse
aims to show you what <b>not to do</b>.
</p>

<h2* id="toc">Table of Contents</h2*>

<toc />

<h2 id="bad-elements">The List of Bad Elements</h2>

<h3 id="no-indentation">No Indentation</h3>

<p>
<a href="http://en.wikipedia.org/wiki/Indent_style">Indentation</a> means
that the contents of every block are promoted from their containing environment
by using a shift of some space. This makes the code easier to read and follow.
</p>

<p>
Code without indentation is harder to read and so should be avoided.
<a href="http://en.wikipedia.org/wiki/Indent_style">The Wikipedia article</a>
lists several styles - pick one and follow it.
</p>

<h3 id="no-strict-and-warnings">No "use strict;" and "use warnings;"</h3>

<p>
All modern Perl code should have the "use strict;" and "use warnings;" pragmas
that prevent or warn against misspelling variable names, using undefined
values, and other bad practices. So start your code (in every file) with this:
</p>

<pre>
#!/usr/bin/env perl

use strict;
use warnings;
</pre>

<p>
Or:
</p>

<pre>
package MyModule;

use strict;
use warnings;
</pre>

<h3 id="open-function-style">Correct style for using the open function</h3>

<p>
<a href="http://perldoc.perl.org/functions/open.html">The open function</a>
is used to open files, sub-processes, etc. The correct style for it is:
</p>

<pre>
open my $input_fh, "&lt;", $input_filename
    or die "Could not open '$input_filename' - $!";
</pre>

the ultimately <b>wrong</b>, insecure and/or outdated styles are:

<pre>
\# Bareword filehandle (type glob), two arguments open (insecure) and no
\# error handling
open INPUT, "&lt;$filename";
</pre>

<h3 id="calling-variables-file">Calling variables "file"</h3>

<p>
Some people call their variables "file". However, file can mean either
<a href="http://en.wikipedia.org/wiki/File_descriptor">file handles</a>,
file names, or the contents of the file. As a result, this should be avoided
and one can use the abbreviations "fh" for file handle, or "fn" for filenames
instead.
</p>

<h3 id="identifiers-without-underscores">Identifiers without underscores</h3>

<p>
Some people name their identifiers as several words all in lowercase and
not separated by underscores ("_"). As a result, this makes the code harder
to read. So instead of:
</p>

<pre>
my @listofnames;
</pre>

<p>
Say:
</p>

<pre>
my @list_of_names;
</pre>

<p>
Or maybe:
</p>

<pre>
my @names_list;
</pre>

<h3 id="prototypes">Don't use prototypes for subroutines</h3>

<p>
Some people are tempted to declare their subroutines using
<tt>sub my_function ($$@)</tt>, with the signature of the accepted parameter
types, which is called a prototype. However, this tends to break code more
often than not, and should be avoided.
</p>

<p>
If you're looking for parameter lists to functions and methods, take a look
at <cpan_self_dist d="Devel-Declare" /> from
CPAN. But don't use prototypes.
</p>

<h3 id="ampersand-in-subroutine-calls">Ampersand in Subroutine Calls</h3>

<p>
One should not call a subroutine using <tt>&amp;myfunc(@args)</tt> unless
you're sure that is what you want to do (like overriding prototypes). Normally
saying <tt>myfunc(@args)</tt> is better.
</p>

<h3 id="assigning-from-dollar-underscore">Assigning from $_</h3>

<p>
Some people write code like the following:
</p>

<pre>
while (&lt;$my_fh&gt;)
{
    my $line = $_;
    \# Do something with $line...
}
</pre>

<p>
Or:
</p>

<pre>
foreach (@users)
{
    my $user = $_;

    \# Process $user...
}
</pre>

<p>
However, you can easily assign the explicit and lexical variables in the
loop's opening line like so:
</p>

<pre>
while (my $line = &lt;$my_fh&gt;)
{
    \# Do something with $line...
}
</pre>

<p>
and:
</p>

<pre>
foreach my $user (@users)
{
    \# Process $user...
}
</pre>

<h3 id="foreach-lines">Using "foreach" on lines</h3>

<p>
Some people may be tempted to write this code:
</p>

<pre>
foreach my $line (&lt;$my_file_handle&gt;)
{
    \# Do something with $line.
}
</pre>

<p>
This code appears to work but what it does is read the entire contents of the
file pointed by $my_file_handle into a (potentially long) list of lines, and
then iterate over them. This is inefficient. In order to read one line
at a time, use this instead:
</p>

<pre>
while (my $line = &lt;$my_file_handle&gt;)
{
    \# Do something with $line.
}
</pre>

<h3 id="string-notation">String Notation</h3>

<p>
Perl has a flexible way to write strings and other delimiters, and you should
utilize it for clarity. If you find yourself writing long strings, write them
as <a href="http://en.wikipedia.org/wiki/Here_document">here-documents</a>:
</p>

<pre>
my $long_string_without_interpolation = &lt;&lt;'EOF';
Hello there. I am a long string.
I am part of the string.
And so am I.
EOF

# do stuff with $long_string_without_interpolation
</pre>

<p>
There are also <tt>&lt;&lt;"EOF"</tt> for strings with interpolation
and <tt>&lt;&lt;`EOF`</tt> for trapping command output. Make sure you never
use bareword here documents <tt>&lt;&lt;EOF</tt> which are valid syntax,
but many people are never sure whether they are <tt>&lt;&lt;"EOF"</tt> or
<tt>&lt;&lt;`EOF`</tt>.
</p>

<p>
If your strings are not too long but contain the special characters that
correspond with the default delimiters (e.g: <tt>'</tt>, <tt>"</tt>,
<tt>`</tt>, <tt>/</tt> etc.), then you can use the initial letter followed
by any arbitrary delimiter notation: <tt>m{\A/home/sophie/perl}</tt>,
<tt>q/My name is 'Jack' and I called my dog "Diego"./</tt>.
</p>

<h3 id="slurp">Slurping a file (i.e: Reading it all into memory)</h3>

<p>
One can see several bad ways to read a file into memory in Perl. Among them
are:
</p>

<pre>
\# Not portable and suffers from possible
\# shell code injection.
my $contents = `cat $filename`;

\# Wasteful of CPU and memory:
my $contents = join("", &lt;$fh&gt;);

\# Even more so:
my $contents = '';
while (my $line = &lt;$fh&gt;)
{
    $contents .= $line;
}
</pre>

<p>
You should avoid them all. Instead the proper way to read an entire file
into a long string is to either use CPAN distributions for that such as
<cpan_self_dist d="File-Slurp" /> or
<cpan_self_dist d="IO-All" />, or alternatively
write down the following function and use it:
</p>

<pre>
sub _slurp
{
    my $filename = shift;

    open my $in, "&lt;", $filename
        or die "Cannot open '$filename' for slurping - $!";

    local $/;
    my $contents = &lt;$in&gt;;

    close($in);

    return $contents;
}
</pre>

<h3 id="paragraphs">Write code in Paragraphs using Empty Lines</h3>

<p>
If one of your blocks is long, split it into "code paragraphs", with empty
lines between them and with each paragraph doing one thing. Then, it may be a
good idea to precede each paragraph with a comment explaining what it does, or
to extract it into its own function or method.
</p>

<h3 id="io-socket">Use IO::Socket and friends instead of lower-level calls</h3>

<p>
One should use <cpan_mod m="IO::Socket">the IO::Socket</cpan_mod> family of
modules for networking Input/Output instead of the
lower-level socket()/connect()/bind()/etc. calls. As of this writing,
<pdoc d="perlipc"></pdoc> contains outdated information demonstrating how
to use the lowere-level API which is not recommended.
</p>

<h3 id="subroutine-arguments">Subroutine Arguments Handling</h3>

<p>
The first thing to know about handling arguments for Subroutines is to avoid
refering to them directly by index. Imagine you have the following code:
</p>

<pre>
sub my_function
{
    my $first_name = $_[0];
    my $street = $_[1];
    my $city = $_[2];
    my $country = $_[3];
    .
    .
    .
}
</pre>

<p>
Now, what if you want to add <tt>$last_name</tt> between <tt>$first_name</tt>?
You'll have to promote all the indexes afterwards! Instead do either:
</p>

<pre>
sub my_function
{
    my $first_name = shift;
    my $street = shift;
    my $city = shift;
    my $country = shift;
    .
    .
    .
}
</pre>

<p>
Or:
</p>

<pre>
sub my_function
{
    my ($first_name, $street, $city, $country) = @_;
    .
    .
    .
}
</pre>

<h4 id="clobbering-arrays-or-hashes">Don't clobber arrays or hashes</h4>

<p>
Often people ask how to pass arrays or hashes to subroutines. The answer is
that the right way to do it is to pass them as a reference as an argument
to the subroutine:
</p>

<pre>
sub calc_polynomial
{
    my ($x, $coefficients) = @_;

    my $x_power = 1;

    my $result = 0;

    foreach my $coeff (@{$coefficients})
    {
        $result += $coeff * $x_power;
    }
    continue
    {
        $x_power *= $x;
    }

    return $result;
}

print "(4*x^2 + 2x + 1)(x = 5) = ", calc_polynomial(5, [1, 2, 4]);
</pre>

<p>
You shouldn't clobber the subroutine's arguments list with entire arrays
or hashes (e.g: <tt>my_func(@array1, @array2);</tt> or
<tt>my_func(%myhash, $scalar)</tt> ), as this will make it difficult to
extract from <tt>@_</tt>.
</p>

<h4 id="named-parameters">Named Parameters</h4>

<p>
If the number of parameters that your subroutine accepts gets too long, or
if you have too many optional parameters, make sure you convert it to use
named arguments. The standard way to do it is to pass a hash reference or
a hash of arguments to the subroutine:
</p>

<pre>
sub send_email
{
    my $args = shift;

    my $from_address = $args-&gt;{from};
    my $to_addresses = $args-&gt;{to};
    my $subject = $args-&gt;{subject};
    my $body = $args-&gt;{body};
    .
    .
    .
}

send_email(
    {
        from =&gt; 'shlomif@perl-begin.org',
        to =&gt; ['shlomif@perl-begin.org', 'sophie@perl-begin.org'],
        subject =&gt; 'Perl-Begin.org Additions',
        .
        .
        .

    }
);
</pre>

<h3 id="chop">Avoid using chop() to trim newlines characters from lines</h3>

<p>
Don't use <a href="http://perldoc.perl.org/functions/chop.html">the built-in
function chop()</a> in order to remove newline characters from the end
of lines read using the diamond operator (<tt>&lt;&gt;</tt>), because this
may cause the last character in a line without a line feed character to be
removed. Instead, use <a 
href="http://perldoc.perl.org/functions/chomp.html">chomp()</a>. 
</p>

<p>
If you expect to process DOS/Windows-like text files whose lines end with the
dual Carriage Return-Line Feed character on Unix systems then use the
following in order to trim them: <tt>$line =~ s/\x0d?\x0a\z//;</tt>.
</p>

<p>
For more information see:
</p>

<ul>
<li>
<a href="http://onlamp.com/pub/a/onlamp/2006/08/17/understanding-newlines.html">"Understanding Newlines"</a> - by Xavier Noria on OnLAMP.com.
</li>
<li>
<a href="http://en.wikipedia.org/wiki/Newline">Wikipedia article about newlines</a>
</li>
</ul>

<h3 id="lowercase_modules_and_pkgs">Don't start Modules and Packages with a Lowercase Letter</h3>

<p>
Both modules and packages (the latter also known as namespaces) and all 
intermediate components thereof should always start with an uppercase letter,
because modules and packages that start with a lowercase letter are
reserved for pragmas. So this is bad:
</p>

<pre>
\# Bad code!
\# This is file person.pm
package person;

use strict;
use warnings;
1;
</pre>

<p>
And this would be better:
</p>

<pre>
\# Better code!
\# This is file MyProject/Person.pm
package MyProject::Person;

use strict;
use warnings;
.
.
.
1;
</pre>

<h3 id="indirect-object-notation">Avoid Indirect Object Notation</h3>

<p>
Don't use the so-called "Indirect-object notation" which can be seen in a lot
of old code and tutorials and is more prone to errors:
</p>

<pre>
\# Bad code!
my $new_object = new MyClass @params;
</pre>

<p>
Instead use the <tt>MyClass-&gt;new(...)</tt> notation:
</p>

<pre>
my $new_object = MyClass-&gt;new(@params);
</pre>

<h3 id="dollar-dollar">$$myarray_ref[$idx] or $$myhash_ref{$key}</h3>

<p>
Don't write <tt>$$myarray_ref[$idx]</tt>, which is cluttered and can be easily
confused with <tt>(${$myarray_ref})-&gt;[$idx]</tt>. Instead, use the
arrow operator - <tt>$myarray_ref-&gt;[$idx]</tt>. This also applies for
hash references - <tt>$myhash_ref-&gt;{$key}</tt>.
</p>

<h3 id="c-style-for-loops">C-style for loops</h3>

<p>
Some beginners to Perl tend to use C-style-for-loops to loop over an array's
elements:
</p>

<pre>
for (my $i=0 ; $i &lt; @array ; $i++)
{
    \# Do something with $array[$i]
}
</pre>

<p>
However, iterating over the array itself would normally be preferable:
</p>

<pre>
foreach my $elem (@array)
{
    \# Do something with $elem.
}
</pre>

<p>
If you still need the index, do:
</p>

<pre>
foreach my $idx (0 .. $#array)
{
    my $elem = $array[$idx];

    \# Do something with $idx and $elem.
}

\# perl-5.12.0 and above:
foreach my $idx (keys(@array))
{
    my $elem = $array[$idx];

    \# Do something with $idx and $elem.
}

\# Also perl-5.12.0 and above.
while (my ($idx, $elem) = each(@array))
{
    \# Do something with $idx and $elem.
}
</pre>

<p>
An arbitrary C-style for loop can be replaced with a while loop with 
a <tt>continue</tt> block.
</p>

<h3 id="non-intrusive-commenting">Avoid Intrusive Commenting</h3>

<p>
Some commenting is too intrusive and interrupts the flow of reading the code.
Examples for that are the <tt>########################</tt> hard-rules that
some people put in their code, the comments using multiple 
<a href="http://en.wikipedia.org/wiki/Number_sign">number signs ("#")</a>,
like <tt>####</tt>, or excessively long comment block. Please avoid all those.
</p>

<p>
Some schools of software engineering argue that if the code's author feels
that a comment is needed, it usually indicates that the code is not clear 
and should be factored better (like extracting a method or a subroutine with
a meaningful name.). It probably does not mean that you should avoid writing
comments altogether, but excessive commenting could prove as a red flag.
</p>

<p>
If you're interested in documenting the public interface of your modules and
command-line programs, refer <pdoc d="perlpod">, Perl's Plain Old
Documentation (POD)</pdoc>, which allows one to quickly and easily document
one's code. POD has
<a href="http://search.cpan.org/search?query=pod&amp;mode=all">many extensions
available on CPAN</a>, which may prove of use.
</p>

<h3 id="accessing_object_slots_directly">Accessing Object Slots Directly</h3>

<p>
Since <a href="$(ROOT)/topics/object-oriented/">Perl objects</a> are simple
references some programmers are tempted to access them directly: 
</p>

<pre>
\# Bad code.
$self-&gt;{'name'} = "John";
print "I am ", $self-&gt;{'age'}, " years old\n";

\# Or even (Really bad code:)
$self-&gt;[NAME()] = "John";
</pre>

<p>
However, this is sub-optimal as explained in
<a href="http://www.shlomifish.org/lecture/Perl/Newbies/lecture5/accessors/">the
Perl 
for Newbies section about "Accessors"</a> and one should use accessors oneself
using code like that:
</p>

<pre>
\# Good code.
$self-&gt;_name("John");
print "I am ", $self-&gt;_age(), " years old\n";
</pre>

<p>
As noted in the link, you can use one of CPAN's many accessor generators to
generate accessors for you.
</p>

<h3 id="caret_and_dollar_sign_in_regexes">'^' and '$' in Regular Expressions</h3>

<p>
Some people use "^" and "$" in regular expressions to mean
beginning-of-the-string or end-of-the-string. However, they can mean
beginning-of-a-line and end-of-a-line respectively using the <tt>/m</tt> flag 
which is confusing. It's a good idea to use <tt>\A</tt> for start-of-string
and <tt>\z</tt> for end-of-string always, and to specify the <tt>/m</tt> flag
if one needs to use "^" and "$" for start/end of a line.
</p>

<h3 id="magic_numbers">Magic Numbers</h3>

<p>
Your code should not include <a href="http://en.wikipedia.org/wiki/Magic_number_%28programming%29#Unnamed_numerical_constants">unnamed 
numerical constants also known as "magic numbers" or "magic constants"</a>. 
For example, there is one in this code to shuffle a deck of cards:
</p>

<pre>
\# Bad code.
for my $i (0 .. 51)
{
    my $j = $i + int(rand(52-$i));
    @cards[$i,$j] = @cards[$j,$i];
}
</pre>

<p>
This code is bad because the meaning of 52 and 51 is not explained and they
are arbitrary. A better code would be:
</p>


<pre>
\# Good code.
\# One of:
my $deck_size = 52;
Readonly my $deck_size =&gt; 52;

for my $i (0 .. $deck_size-1)
{
    my $j = $i + int(rand($deck_size-$i));
    @cards[$i,$j] = @cards[$j,$i];
}
</pre>

<p>
(Of course in this case, you may opt to use a shuffle function from CPAN,
but this is just for the sake of demonstration.).
</p>

<h2 id="sources_of_advice">Sources of This Advice</h2>

<p>
This is a short list of the sources from which this advice was taken which
also contains material for further reading:
</p>

<ol>
<li>
<p>
<a href="$(ROOT)/src/books/advanced/#pbp">The
Book "Perl Best Practices"</a> by Damian Conway - contains a lot of good
advice and food for thought, but sometimes should be deviated from.
Also see the 
<a href="https://www.socialtext.net/perl5/index.cgi?pbp_module_recommendation_commentary">"PBP 
Module Recommendation Commentary"</a> on the Perl 5 Wiki.
</p>
</li>

<li>
<p>
<a href="https://www.socialtext.net/perl5/index.cgi?ancient_perl">"Ancient 
Perl"</a> on the Perl 5 Wiki.
</p>
</li>

<li>
<p>
<a href="http://modernperlbooks.com/">chromatic's "Modern Perl" Book and
Blog</a>
</p>
</li>

<li>
<p>
Advice given by people on <a href="$(ROOT)/irc/#freenode">Freenode's #perl
channel</a>, on the Perl Beginners mailing list, and on other Perl forums.
</p>
</li>

</ol>

