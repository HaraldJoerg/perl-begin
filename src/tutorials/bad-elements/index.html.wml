#include '../template.wml'

<latemp_subject "Perl Elements to Avoid" />

<latemp_more_keywords "elements, antipatterns, anti, patterns, help, ancient, ancient perl, modern, modern perl, avoid, bad perl, old tutorials, what to avoid" />

<p>
Often when people ask for help with Perl code, they show Perl code that
suffers from many bad or outdated elements. This is expected as there
are many bad Perl tutorials out there, and lots of bad code that people
have learned from, but it is still not good. In order to not get "yelled at" 
for using these, here is the document of the bad elements that people
tend to use and better practices.
</p>

<h2 id="bad-elements">The List of Bad Elements</h2>

<h3 id="no-indentation">No Indentation</h3>

<p>
<a href="http://en.wikipedia.org/wiki/Indent_style">Indentation</a> means 
that the contents of every block are promoted from their containing environment
by using a shift of some space. This makes the code easier to read and follow.
</p>

<p>
Code without indentation is harder to read and so should be avoided. 
<a href="http://en.wikipedia.org/wiki/Indent_style">The Wikipedia article</a>
lists several styles - pick one and follow it.
</p>

<h3 id="no-strict-and-warnings">No "use strict;" and "use warnings;"</h3>

<p>
All modern Perl code should have the "use strict;" and "use warnings;" pragmas
that prevent or warn against misspelling variable names, using undefined 
values, and other bad practices. So start your code (in every file) with this:
</p>

<pre>
#!/usr/bin/env perl

use strict;
use warnings;
</pre>

<p>
Or:
</p>

<pre>
package MyModule;

use strict;
use warnings;
</pre>

<h3 id="open-function-style">Correct style for using the open function</h3>

<p>
<a href="http://perldoc.perl.org/functions/open.html">The open function</a>
is used to open files, sub-processes, etc. The correct style for it is:
</p>

<pre>
open my $input_fh, "&lt;", $input_filename
    or die "Could not open '$input_filename' - $!";
</pre>

the ultimately <b>wrong</b>, insecure and/or outdated styles are:

<pre>
\# Bareword filehandle (type glob), two arguments open (insecure) and no
\# error handling
open INPUT, "&lt;$filename"; 
</pre>

<h3 id="calling-variables-file">Calling variables "file"</h3>

<p>
Some people call their variables "file". However, file can mean either
<a href="http://en.wikipedia.org/wiki/File_descriptor">file handles</a>,
file names, or the contents of the file. As a result, this should be avoided
and one can use the abbreviations "fh" for file handle, or "fn" for filenames
instead.
</p>

<h3 id="identifiers-without-underscores">Identifiers without underscores</h3>

<p>
Some people name their identifiers as several words all in lowercase and 
not separated by underscores ("_"). As a result, this makes the code harder
to read. So instead of:
</p>

<pre>
my @listofnames;
</pre>

<p>
Say:
</p>

<pre>
my @list_of_names;
</pre>

<p>
Or maybe:
</p>

<pre>
my @names_list;
</pre>

<h3 id="prototypes">Don't use prototypes for subroutines</h3>

<p>
Some people are tempted to declare their subroutines using 
<tt>sub my_function ($$@)</tt>, with the signature of the accepted parameter 
types, which is called a prototype. However, this tends to break code more
often than not, and should be avoided.
</p>

<p>
If you're looking for parameter lists to functions and methods, take a look
at <a href="http://search.cpan.org/dist/Devel-Declare/">Devel-Declare</a> from
CPAN. But don't use prototypes.
</p>

<h3 id="ampersand-in-subroutine-calls">Ampersand in Subroutine Calls</h3>

<p>
One should not call a subroutine using <tt>&amp;myfunc(@args)</tt> unless
you're sure that is what you want to do (like overriding prototypes). Normally
saying <tt>myfunc(@args)</tt> is better.
</p>

<h3 id="assigning-from-dollar-underscore">Assigning from $_</h3>

<p>
Some people write code like the following:
</p>

<pre>
while (&lt;$my_fh&gt;)
{
    my $line = $_;
    \# Do something with $line...
}
</pre>

<p>
Or:
</p>

<pre>
foreach (@users)
{
    my $user = $_;

    \# Process $user...
}
</pre>

<p>
However, you can easily assign the explicit and lexical variables in the
loop's opening line like so:
</p>

<pre>
while (my $line = &lt;$my_fh&gt;)
{
    \# Do something with $line...
}
</pre>

<p>
and:
</p>

<pre>
foreach my $user (@users)
{
    \# Process $user...
}
</pre>

<h3 id="foreach-lines">Using "foreach" on lines</h3>

<p>
Some people may be tempted to write this code:
</p>

<pre>
foreach my $line (&lt;$my_file_handle&gt;)
{
    \# Do something with $line.
}
</pre>

<p>
This code appears to work but what it does is read the entire contents of the 
file pointed by $my_file_handle into a (potentially long) list of lines, and
then iterate over them. This is inefficient. In order to read one line
at a time, use this instead:
</p>

<pre>
while (my $line = &lt;$my_file_handle&gt;)
{
    \# Do something with $line.
}
</pre>

<h2 id="string-notation">String Notation</h2>

<p>
Perl has a flexible way to write strings and other delimiters, and you should
utilize it for clarity. If you find yourself writing long strings, write them
as <a href="http://en.wikipedia.org/wiki/Here_document">here-documents</a>:
</p>

<pre>
my $long_string_without_interpolation = &lt;&lt;'EOF';
Hello there. I am a long string.
I am part of the string.
And so am I.
EOF

# do stuff with $long_string_without_interpolation
</pre>

<p>
There are also <tt>&lt;&lt;"EOF"</tt> for strings with interpolation
and <tt>&lt;&lt;`EOF`</tt> for trapping command output. Make sure you never
use bareword here documents <tt>&lt;&lt;EOF</tt> which are valid syntax,
but people are never sure whether they are <tt>&lt;&lt;"EOF"</tt> or
<tt>&lt;&lt;`EOF`</tt>.
</p>

<p>
If your strings are not too long but contain the special characters that
correspond with the default delimiters (e.g: <tt>'</tt>, <tt>"</tt>,
<tt>`</tt>, <tt>/</tt> etc.), then you can use the initial letter followed
by any arbitrary delimiter notation: <tt>m{\A/home/sophie/perl}</tt>,
<tt>q/My name is 'Jack' and I called my dog "Diego"./</tt>.
</p>
