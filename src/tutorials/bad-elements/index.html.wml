#include '../template.wml'

<latemp_subject "Perl Elements to Avoid" />

<latemp_more_keywords "elements, antipatterns, anti, patterns, help, ancient, ancient perl, modern, modern perl, avoid, bad perl, old tutorials, what to avoid" />

<p>
Often when people ask for help with Perl code, they show Perl code that
suffers from many bad or outdated elements. This is expected as there
are many bad Perl tutorials out there, and lots of bad code that people
have learned from, but it is still not good. In order to not get "yelled at" 
for using these, here is the document of the bad elements that people
tend to use and better practices.
</p>

<h2 id="bad-elements">The List of Bad Elements</h2>

<h3 id="no-indentation">No Indentation</h3>

<p>
<a href="http://en.wikipedia.org/wiki/Indent_style">Indentation</a> means 
that the contents of every block are promoted from their containing environment
by using a shift of some space. This makes the code easier to read and follow.
</p>

<p>
Code without indentation is harder to read and so should be avoided. 
<a href="http://en.wikipedia.org/wiki/Indent_style">The Wikipedia article</a>
lists several styles - pick one and follow it.
</p>

<h3 id="no-strict-and-warnings">No "use strict;" and "use warnings;"</h3>

<p>
All modern Perl code should have the "use strict;" and "use warnings;" pragmas
that prevent or warn against misspelling variable names, using undefined 
values, and other bad practices. So start your code (in every file) with this:
</p>

<pre>
#!/usr/bin/env perl

use strict;
use warnings;
</pre>

<p>
Or:
</p>

<pre>
package MyModule;

use strict;
use warnings;
</pre>

<h3 id="open-function-style">Correct style for using the open function</h3>

<p>
<a href="http://perldoc.perl.org/functions/open.html">The open function</a>
is used to open files, sub-processes, etc. The correct style for it is:
</p>

<pre>
open my $input_fh, "&lt;", $input_filename
    or die "Could not open '$input_filename' - $!";
</pre>

the ultimately <b>wrong</b>, insecure and/or outdated styles are:

<pre>
\# Bareword filehandle (type glob), two arguments open (insecure) and no
\# error handling
open INPUT, "&lt;$filename"; 
</pre>

<h3 id="calling-variables-file">Calling variables "file"</h3>

<p>
Some people call their variables "file". However, file can mean either
<a href="http://en.wikipedia.org/wiki/File_descriptor">file handles</a>,
file names, or the contents of the file. As a result, this should be avoided
and one can use the abbreviations "fh" for file handle, or "fn" for filenames
instead.
</p>

<h3 id="identifiers-without-underscores">Identifiers without underscores</h3>

<p>
Some people name their identifiers as several words all in lowercase and 
not separated by underscores ("_"). As a result, this makes the code harder
to read. So instead of:
</p>

<pre>
my @listofnames;
</pre>

<p>
Say:
</p>

<pre>
my @list_of_names;
</pre>

<p>
Or maybe:
</p>

<pre>
my @names_list;
</pre>

<h3 id="prototypes">Don't use prototypes for subroutines</h3>

<p>
Some people are tempted to declare their subroutines using 
<tt>sub my_function ($$@)</tt>, with the signature of the accepted parameter 
types, which is called a prototype. However, this tends to break code more
often than not, and should be avoided.
</p>

<p>
If you're looking for parameter lists to functions and methods, take a look
at <a href="http://search.cpan.org/dist/Devel-Declare/">Devel-Declare</a> from
CPAN. But don't use prototypes.
</p>

<h3 id="ampersand-in-subroutine-calls">Ampersand in Subroutine Calls</h3>

<p>
One should not call a subroutine using <tt>&amp;myfunc(@args)</tt> unless
you're sure that is what you want to do (like overriding prototypes). Normally
saying <tt>myfunc(@args)</tt> is better.
</p>

<h3 id="assigning-from-dollar-underscore">Assigning from $_</h3>

<p>
Some people write code like the following:
</p>

<pre>
while (&lt;$my_fh&gt;)
{
    my $line = $_;
    \# Do something with $line...
}
</pre>

<p>
Or:
</p>

<pre>
foreach (@users)
{
    my $user = $_;

    \# Process $user...
}
</pre>

<p>
However, you can easily assign the explicit and lexical variables in the
loop's opening line like so:
</p>

<pre>
while (my $line = &lt;$my_fh&gt;)
{
    \# Do something with $line...
}
</pre>

<p>
and:
</p>

<pre>
foreach my $user (@users)
{
    \# Process $user...
}
</pre>

<h3 id="foreach-lines">Using "foreach" on lines</h3>

<p>
Some people may be tempted to write this code:
</p>

<pre>
foreach my $line (&lt;$my_file_handle&gt;)
{
    \# Do something with $line.
}
</pre>

<p>
This code appears to work but what it does is read the entire contents of the 
file pointed by $my_file_handle into a (potentially long) list of lines, and
then iterate over them. This is inefficient. In order to read one line
at a time, use this instead:
</p>

<pre>
while (my $line = &lt;$my_file_handle&gt;)
{
    \# Do something with $line.
}
</pre>

<h2 id="string-notation">String Notation</h2>

<p>
Perl has a flexible way to write strings and other delimiters, and you should
utilize it for clarity. If you find yourself writing long strings, write them
as <a href="http://en.wikipedia.org/wiki/Here_document">here-documents</a>:
</p>

<pre>
my $long_string_without_interpolation = &lt;&lt;'EOF';
Hello there. I am a long string.
I am part of the string.
And so am I.
EOF

# do stuff with $long_string_without_interpolation
</pre>

<p>
There are also <tt>&lt;&lt;"EOF"</tt> for strings with interpolation
and <tt>&lt;&lt;`EOF`</tt> for trapping command output. Make sure you never
use bareword here documents <tt>&lt;&lt;EOF</tt> which are valid syntax,
but people are never sure whether they are <tt>&lt;&lt;"EOF"</tt> or
<tt>&lt;&lt;`EOF`</tt>.
</p>

<p>
If your strings are not too long but contain the special characters that
correspond with the default delimiters (e.g: <tt>'</tt>, <tt>"</tt>,
<tt>`</tt>, <tt>/</tt> etc.), then you can use the initial letter followed
by any arbitrary delimiter notation: <tt>m{\A/home/sophie/perl}</tt>,
<tt>q/My name is 'Jack' and I called my dog "Diego"./</tt>.
</p>

<h3 id="slurp">Slurping a file (i.e: Reading it all into memory)</h3>

<p>
One can see several bad ways to read a file into memory in Perl. Among them
are:
</p>

<pre>
\# Not portable and suffers from possible
\# shell code injection.
my $contents = `cat $filename`; 

\# Wasteful of CPU and memory:
my $contents = join("", &lt;$fh&gt;);

\# Even more so:
my $contents = '';
while (my $line = &lt;$fh&gt;)
{
    $contents .= $line;
}
</pre>

<p>
You should avoid them all. Instead the proper way to read an entire file
into a long string is to either use CPAN distributions for that such as 
<a href="http://search.cpan.org/dist/File-Slurp/">File-Slurp</a> or
<a href="http://search.cpan.org/dist/IO-All/">IO-All</a>, or alternatively
write down the following function and use it:
</p>

<pre>
sub _slurp
{
    my $filename = shift;

    open my $in, "&lt;", $filename
        or die "Cannot open '$filename' for slurping - $!";

    local $/;
    my $contents = &lt;$in&gt;;

    close($in);

    return $contents;
}
</pre>

<h3 id="paragraphs">Write code in Paragraphs using Empty Lines</h3>

<p>
If one of your blocks is long, split it into "code paragraphs", with empty
lines between them and with each paragraph doing one thing. Then, it may be a
good to precede each paragraph with a comment explaining what it does, or
to extract it into its own function or method.
</p>

<h3 id="io-socket">Use IO::Socket and friends instead of lower-level calls</h3>

<p>
One should use <a href="http://search.cpan.org/perldoc?IO::Socket">the 
IO::Socket</a> family of modules for networking Input/Output instead of the
lower-level socket()/connect()/bind()/etc. calls. As of this writing, 
<pdoc d="perlipc"></pdoc> contains outdated information demonstrating how
to use the lowere-level API which is not recommended. 
</p>

<h3 id="subroutine-arguments">Subroutine Arguments Handling</h3>

<p>
The first thing to know about handling arguments for Subroutines is to avoid
refering to them directly by index. Imagine you have the following code:
</p>

<pre>
sub my_function
{
    my $first_name = $_[0];
    my $street = $_[1];
    my $city = $_[2];
    my $country = $_[3];
    .
    .
    .
}
</pre>

<p>
Now, what if you want to add <tt>$last_name</tt> between <tt>$first_name</tt>?
You'll have to promote all the indexes afterwards! Instead do either:
</p>

<pre>
sub my_function
{
    my $first_name = shift;
    my $street = shift;
    my $city = shift;
    my $country = shift;
    .
    .
    .
}
</pre>

<p>
Or:
</p>

<pre>
sub my_function
{
    my ($first_name, $street, $city, $country) = @_;
    .
    .
    .
}
</pre>

<h4 id="clobbering-arrays-or-hashes">Don't clobber arrays or hashes</h4>

<p>
Often people ask how to pass arrays or hashes to subroutines. The answer is
that the right way to do it is to pass them as a reference as an argument
to the subroutine:
</p>

<pre>
sub my_func
{
    my ($prefix, $array_ref) = @_;

    foreach my $item (@{$array_ref})
    {
        print $prefix, ": ", $item, "\n";
    }

    return;
}

my @names = (qw(Jack Sophie John David Ernie));

my_func("Please greet", \@names);
</pre>

<p>
You shouldn't clobber the subroutine's arguments list with entire arrays
or hashes (e.g: <tt>my_func(@array1, @array2);</tt> or 
<tt>my_func(%myhash, $scalar)</tt> ), as this will make it difficult to
extract from <tt>@_</tt>.
</p>

<h4 id="named-parameters">Named Parameters</h4>

<p>
If the number of parameters that your subroutine accepts gets too long, or
if you have too many optional parameters, make sure you convert it to use
named arguments. The standard way to do it is to pass a hash reference or
a hash of arguments to the subroutine:
</p>

<pre>
sub send_email
{
    my $args = shift;

    my $from_address = $args-&gt;{from};
    my $to_addresses = $args-&gt;{to};
    my $subject = $args-&gt;{subject};
    my $body = $args-&gt;{body};    
    .
    .
    .
}

send_email(
    {
        from =&gt; 'shlomif@perl-begin.org',
        to =&gt; ['shlomif@perl-begin.org', 'sophie@perl-begin.org'],
        subject =&gt; 'Perl-Begin.org Additions',
        .
        .
        .

    }
);
</pre>
